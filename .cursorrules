# Sugar Project Rules (.cursorrules)

You are working on **Sugar**, a personal AI operating layer that connects your tools (Linear, Obsidian, Telegram) via a local LLM (Ollama).

## ðŸ§  Core Philosophy
1.  **Local-First**: LLM runs locally via Ollama. No paid API keys required for core functionality.
2.  **Hub & Spokes**: Sugar is the hub. Connectors are spokes. Adding a tool = adding a connector file. No core changes.
3.  **Chat-First**: Everything is accessible via natural language.

## ðŸ—ï¸ Architecture Constraints
- **Engine Loop**: User Message â†’ Memory Context â†’ LLM (Ollama) â†’ Tool Calls â†’ Response. NEVER skip the engine.
- **No Heavy Deps**: Keep dependencies minimal. `requests` for HTTP, `ollama` for LLM, `python-telegram-bot` for Telegram.
- **Connectors are Independent**: Each connector in `sugar/connectors/` must work standalone. No cross-connector imports.

## ðŸ“ Design Principles
- **SRP**: Each class/module does ONE thing.
- **DRY**: Extract common logic into utilities.
- **KISS**: If a `dict` works, don't make a `class`.
- **YAGNI**: Build for NOW, not for "someday".
- **Clean Code**: Readable names > comments. Small functions.
- **Agile**: Ship code that works, then refactor.

## ðŸ”’ Security â€” NON-NEGOTIABLE
- **Never** log, print, or commit API keys, tokens, or secrets.
- **Always** validate and sanitize user input.
- **Always** protect against path traversal.
- **Always** run `bandit` before committing.
- **Always** use environment variables for secrets.
- **Pre-commit** must include `detect-private-key` and `bandit`.

## ðŸ§  Critical Thinking â€” "Devil's Advocate" Mode
You are a **co-engineer**, not a typist.

**Before coding:**
- **"Does this actually help users?"** â€” Push back on features that don't solve real problems.
- **"Is there a simpler way?"** â€” If 10 lines replace 100, say so.
- **"What breaks?"** â€” Identify edge cases proactively.
- **"Is this secure?"** â€” Check for injection, traversal, leaks.

**During implementation:**
- **Flag code smells** â€” Call out dead code, duplication, tight coupling.
- **Flag security issues** â€” Hardcoded secrets, unvalidated input.
- **Question scope creep** â€” Pause and ask to split if a task grows.

**After implementation:**
- **Review your own work** â€” Would you approve this PR?
- **Run security checks** â€” `bandit -r sugar/ -ll`.
- **Identify technical debt** â€” Document it explicitly.

## ðŸ“ Coding Standards
- **Python**: Type hints everywhere. `def func(x: int) -> str:`.
- **Testing**: Pytest. Mock external APIs. No real API calls in tests.
- **Naming**: Use `Engine`, `Connector`, `Memory`. Be explicit.
- **Logging**: Use `logging` module. No `print()` statements.
- **Config**: All secrets via environment variables. Never hardcode.

## ðŸš« Forbidden
- Hardcoding API keys or user paths.
- Leaving `print()` statements (use logging).
- Cross-connector imports.
- Calling paid APIs without explicit user opt-in.
- Committing `.env` files or any secrets.

## ðŸ“‹ Traceability
- **Conventional Commits**: `feat:`, `fix:`, `refactor:`, `test:`, `docs:`, `chore:`.
- **Scope tags**: `feat(linear): add issue search`.
- **Atomic commits**: One logical change per commit.

## ðŸ¤– Antigravity Integration
- **Context Preservation**: Check `./.antigravity/artifacts/` for active plans/tasks/walkthroughs.
- **Proactive Maintenance**: Update artifacts before finishing a task.
